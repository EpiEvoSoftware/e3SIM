function (numeric)additive_trait(o<Mutation> muts, s trait_type, f cap)
{
	trait_value = size(muts) ? sum(muts.getValue(trait_type)) else 0.0;
	if (trait_value < cap)
	{
		return(trait_value);
	}
	else
	{
		return(cap);
	}
}


function (numeric)bialleleic_trait(o<Mutation> muts, s trait_type, numeric trait_locations, f cap, o<DataFrame> effsize_df)
{
	which_gene = unique(sapply(muts.position, "asInteger((findInterval(applyValue.position, trait_locations) + 1) / 2)"));
	which_trait = strsplit(trait_type, sep="e")[1];
	trait_value = size(which_gene) ? sum(effsize_df.subsetColumns(which_trait + 3)[which_gene]) else 0.0;
	if (trait_value < cap)
	{
		return(trait_value);
	}
	else
	{
		return(cap);
	}
}


initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(nucleotideBased=T);
	initializeTreeSeq();
	
	// Read in the config file and make global variables of different parameters
	source("read_config.slim");
	
	// Initiate the genomic elements and mutation types
	source("genomic_element_init.slim");
}

mutation(m1) {
	// Set mutational effects for new m2 mutation 
	which_gene =asInteger((findInterval(mut.position, trait_locs) + 1) / 2);
	mut.setValue("e0", effsize_pos.subset(which_gene - 1, 3)); 
	mut.setValue("e1", effsize_pos.subset(which_gene - 1, 4)); 
	
	return T;

}

1 first() {
	//// Define blocks to run
	// self reproduction (for mutation accumulation) run every generation
	community.rescheduleScriptBlock(s0, ticks = 2:n_generation);
	// s1, transmission block, run every generation
	community.rescheduleScriptBlock(s1, ticks = 2:n_generation);
	// s2, within-host evolution block, will be disabled if within_host_evolution is false
	if (within_host_evolution==T)
	{
		community.rescheduleScriptBlock(s2, ticks = 2:n_generation);
	}
	// s3, process the infected hosts, recover or sample or go back to exposed
	community.rescheduleScriptBlock(s3, ticks = 2:n_generation);
	// s4, logging this generation's compartment information. Run for all generations
	community.rescheduleScriptBlock(s4, ticks = 2:n_generation);
	// s5, end of simulation block
	community.rescheduleScriptBlock(s5, ticks = n_generation);
	// s6, kill all old pathogens, run at all generations as a complement of the mutation process
	community.rescheduleScriptBlock(s6, ticks = 2:n_generation);
	// s7, treatment block, will activate only at the generations specified by treatment_gens as substitution of s3
	if (multiple_epochs==T) 
	{
		treatment_start = asInteger(treatment_gens[0]);
		treatment_end = asInteger(treatment_gens[1]);
		treatment_start_1 = treatment_start - 1;
		treatment_end_1 = treatment_end + 1;
		community.rescheduleScriptBlock(s7, ticks = treatment_start:treatment_end);
		ori_gen = c(2:treatment_start_1, treatment_end_1:n_generation);
		community.rescheduleScriptBlock(s3, ticks = ori_gen);
	}
	// s8, process the exposed hosts
	if (model=="SEIR")
	{
		community.rescheduleScriptBlock(s8, ticks = 2:n_generation);
	}
	// s9, process recovered individuals
	if (RS_rate > 0)
	{
		community.rescheduleScriptBlock(s9, ticks = 2:n_generation);
	}
	// s10, process this generation's new infections.
	community.rescheduleScriptBlock(s10, ticks = 2:n_generation);
}

1 early() {
	seeds = sort(sample(1:host_size, seed_size));
	// Add N($sample_size) subpopulations (representing N humans in the population) with 0 or 1 elements (Susceptible or Infected)
	labels = c();
	seed_count = 0;
	for (i in 1:host_size)
	{
		if (i == seeds[seed_count])
		{
			sim.addSubpop(i, 1, haploid=T); // Infected hosts
			sim.subpopulations[i - 1].tag = i-1;
			sim.subpopulations[i - 1].individuals.tag = host_size; // Infected State
			labels = c(labels, 2);
			sim.subpopulations[i - 1].genomes.readFromVCF(paste0(cwdir, "/originalvcfs/seed.", seed_count, ".vcf"));
			writeFile(paste0(cwdir, "/seeds.name"), paste0(seed_count, ",", "p", i-1), append=T);
			if (seed_count < seed_size - 1)
			{
				seed_count = seed_count + 1;
			}
		}
		else
		{
			sim.addSubpop(i, 0, haploid=T); // Susceptible
			sim.subpopulations[i - 1].tag = i - 1;
			labels = c(labels, 0);
		}
	}
	// change default mutation type and selection coefficient
	
	print(effsize_pos);
	
	allmuts = sim.subpopulations.individuals.genome1.mutations;
	for (mut in allmuts)
	{
		if (any(mut.position == range_genes))
		{
			mut.setMutationType(1);
			which_gene = asInteger((findInterval(mut.position, trait_locs) + 1) / 2);
			mut.setValue("e0", effsize_pos.subset(which_gene - 1, 3)); 
			mut.setValue("e1", effsize_pos.subset(which_gene - 1, 4)); 	
		}
	}

	

	defineGlobal("Host_states", labels);
}

1 early() {
	// Read into the contact network file
	lines_contact = readFile(paste0(cwdir, "/contact_network.adjlist.modified"));

	for (l in lines_contact)
	{
		ll = strsplit(l, " ");
		ll = asInteger(strsplit(l, " "));
		host = ll[0];
		contact_size = length(ll) - 1;
		if (contact_size > 0)
		{
			sim.subpopulations[host].setValue("Contacts", ll[1:contact_size]);
		}
		else
		{
			sim.subpopulations[host].setValue("Contacts", c());
		}
	}
}

s0 reproduction() {
	itself = individual.subpopulation.addRecombinant(individual.genome1, NULL, NULL, NULL, NULL, NULL);
	itself.tag = individual.tag;
}

s1 reproduction()
{
	// Transmission
	infectors = which(Host_states==2);
	
	for (infector in infectors)
	{	
		infector_subpop = sim.subpopulations[infector];
		contact_ids = infector_subpop.getValue("Contacts");
		if (length(contact_ids)>0)
		{
			infector_pathogen = sample(infector_subpop.individuals, 1);
			muts = infector_pathogen.genome1.mutationsOfType(1);
			transmissibility = additive_trait(muts, "e0", cap_1);
			//transmissibility = size(muts) ? sum(muts.getValue("e0")) else 0.0;


			trans_event = rbinom(length(contact_ids), 1, Infection_rate * transmissibility);
			contacts_states = Host_states[contact_ids];
			
			if (super_infection==T) { infectee_id = contact_ids[which((trans_event==1)&(sim.subpopulations[contact_ids].individualCount < cap_withinhost))]; }
			else { infectee_id = contact_ids[which((trans_event==1)&(contacts_states==0))]; }
			for (i in infectee_id)
			{
				child = sim.subpopulations[i].addRecombinant(infector_pathogen.genome1, NULL, NULL, NULL, NULL, NULL);
				child.tag = infector;
				line = paste(community.tick, infector, i);
				writeFile(paste0(cwdir, "/infection_raw.txt"), line, append=T);
			}
		}
	}
	self.active=F;
}

s6 early()
{
	inds = sim.subpopulations.individuals;
	sim.killIndividuals(inds[inds.age > 0]);
}

s8 early()
{
	hosts = sim.subpopulations;
	recovered_genomes = c();
	recovered_hosts = c();
	popsizeminus1 = host_size-1;
	
	// Deal with exposed individuals
	e_inds = which(Host_states==1); // deal with 1&2 first
	//sim.subpopulations[e_inds].individuals.tag = host_size;
	draw_uniform = runif(length(e_inds));
	state_transition = findInterval(draw_uniform, c(0, activate_rate, activate_rate + ER_rate));
	Host_states[e_inds[which(state_transition==0)]]=2; // state_transition=0 means going from latent to active state (1>2)
	recover_from_e = e_inds[which(state_transition==1)];
	if (length(recover_from_e)>0)
	{
		Host_states[recover_from_e]=3;
		for (ind in recover_from_e)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/recovery.txt"), line1, append=T);
		}
		sim.killIndividuals(sim.subpopulations[recover_from_e].individuals);
	}
}

s3 early(){
	i_inds = which(Host_states==2);
	//sim.subpopulations[i_inds].individuals.tag = host_size;
	draw_uniform = runif(length(i_inds));
	state_transition = findInterval(draw_uniform, c(0, Recovery_rate*sample_rate, Recovery_rate, Recovery_rate + IE_rate));
	recover_from_i = i_inds[which(state_transition<=1)];
	sampled_inds = i_inds[which(state_transition==0)];
	
	if (length(sampled_inds)>0)
	{
		sampled_inds_genomes = c();
		for (ind in sampled_inds)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/sample.txt"), line1, append=T);
			sampled_inds_genomes = c(sampled_inds_genomes, sample(sim.subpopulations[ind].individuals, 1));
		}
		sim.treeSeqRememberIndividuals(sampled_inds_genomes);
		sampled_inds_genomes.genomes.outputVCF(filePath=paste0(cwdir, "/sample_vcfs/", community.tick, ".sampled.vcf"));
	}
	
	if (length(recover_from_i)>0)
	{
		Host_states[recover_from_i]=3;
		for (ind in recover_from_i)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/recovery.txt"), line1, append=T);
		}
		sim.killIndividuals(sim.subpopulations[recover_from_i].individuals);
	}
}

s10 early(){
	s_inds = which((Host_states==0)&(sim.subpopulations.individualCount>0));

	for (s_ind in s_inds)
	{
		s_ind_pathogens = sim.subpopulations[s_ind].individuals;
		remain_strain_tag = sample(s_ind_pathogens, 1).tag;
		sim.killIndividuals(s_ind_pathogens[which(s_ind_pathogens.tag!=remain_strain_tag)]);
		line = paste(community.tick, remain_strain_tag, s_ind);
		writeFile(paste0(cwdir, "/infection.txt"), line, append=T);
		remain_strain_tag = host_size;
	}

	draw_uniform = runif(length(s_inds));
	state_transition = findInterval(draw_uniform, c(0, latent_prob));
	Host_states[s_inds[which(state_transition==0)]]=1; //state_transition=0 means going to latent state while =1 means going to active state
	Host_states[s_inds[which(state_transition > 0)]]=2;
}

s9 early(){
	r_inds = which(Host_states==3);
	draw_uniform = runif(length(r_inds));
	state_transition = findInterval(draw_uniform, c(0, RS_rate));
	Host_states[r_inds[which(state_transition==0)]]=0;
}

s4 late()
{
	writeFile(paste0(cwdir, "/SIR_trajectory.txt"), paste0(sum(Host_states == 0), ", ", sum(Host_states == 1), ", ", sum(Host_states == 2), ", ", sum(Host_states == 3)), append=T);
}

s5 late() 
{
	inds = sim.subpopulations.individuals;
	sim.killIndividuals(inds);
	sim.treeSeqOutput("/Users/px54/Documents/misc_test/test_ourmethod.trees");
	sim.simulationFinished();
}


