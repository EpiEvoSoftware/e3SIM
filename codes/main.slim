initialize() {
	initializeSLiMModelType("nonWF");
	initializeSLiMOptions(nucleotideBased=T);
	//setwd("/Users/px54/Documents/TB_transmissibility/slim_scripts/model_0904/");
	
	// Read in the config file and make global variables of different parameters
	source("read_config.slim");
	
	// Initiate the genomic elements and mutation types
	source("genomic_element_init.slim");
	
	// Define a default param epoch:0 to log which epoch is the simulation currently in (only useful when multiple_epochs:T)
	defineGlobal("epoch", 0);
}


mutation(m2) {

	// draw mutational effects for the new m2 mutation 
	// effects = rmvnorm(1, QTL_mu, QTL_sigma); 
	which_gene =asInteger((findInterval(muts.position, trait_locs) + 1) / 2);
	mut.setValue("e0", effsize_pos.subset(which_gene - 1, 3)); 
	mut.setValue("e1", effsize_pos.subset(which_gene - 1, 4)); 

	// remember all drawn effects, for our final output 
	//old_effects = sim.getValue("all_effects"); 
	//sim.setValue("all_effects", rbind(old_effects, effects));

return T;

}


1 first() {
	//// Define blocks to run
	// s0, an epoch-controlling block
	community.rescheduleScriptBlock(s0, ticks = 2:n_generation);
	// s1, transmission block
	community.rescheduleScriptBlock(s1, ticks = 2:n_generation);
	// s2, within-host evolution block, will be disabled if within_host_evolution is false
	//community.rescheduleScriptBlock(s2, ticks = 2:n_generation);
	// s3, SIR without super-infection modifying module + recovery module
	community.rescheduleScriptBlock(s3, ticks = 2:n_generation);
	// s4, late module
	community.rescheduleScriptBlock(s3, ticks = 2:n_generation);
	// s5, end of simulation block
	community.rescheduleScriptBlock(s5, ticks = n_generation);
	// s6, change effect size block, only activated in certain epoch changing generations
	if (multiple_epochs==T) 
	{
		treatment_start = asInteger(treatment_gens[0]);
		treatment_end = asInteger(treatment_gens[1]);
		treatment_start_1 = treatment_start - 1;
		treatment_end_1 = treatment_end + 1;
		community.rescheduleScriptBlock(s6, ticks = treatment_start:treatment_end);
		ori_gen = c(2:treatment_start_1, treatment_end_1:n_generation);
		community.rescheduleScriptBlock(s3, ticks = ori_gen);
	}
	else { community.rescheduleScriptBlock(s6, ticks = asInteger(5000)); }
}

// Seeds read-in module
1 early() {
	seeds = sort(sample(1:host_size, seed_size));
	// Add N($sample_size) subpopulations (representing N humans in the population) with 0 or 1 elements (Susceptible or Infected)
	labels = c();
	seed_count = 0;
	for (i in 1:host_size)
	{
		if (i == seeds[seed_count])
		{
			sim.addSubpop(i, 1, haploid=T); // Infected hosts
			sim.subpopulations[i - 1].tag = i-1;
			sim.subpopulations[i - 1].individuals.tag = host_size; // Infected State
			labels = c(labels, 2);
			sim.subpopulations[i - 1].genomes.readFromVCF(paste0(cwdir, "/originalvcfs/seed.", seed_count, ".vcf"));
			writeFile(paste0(cwdir, "/seeds.name"), paste0(seed_count, ",", "p", i-1), append=T);
			if (seed_count < 9)
			{
				seed_count = seed_count + 1;
			}
		}
		else
		{
			sim.addSubpop(i, 0, haploid=T); // Susceptible
			sim.subpopulations[i - 1].tag = i - 1;
			labels = c(labels, 0);
		}
	}
	// change default mutation type and selection coefficient
	
	print(effsize_pos);
	
	allmuts = sim.subpopulations.individuals.genome1.mutations;
	for (mut in allmuts)
	{
		if (any(mut.position == range_genes))
		{
			mut.setMutationType(1);
			which_gene = asInteger((findInterval(mut.position, trait_locs) + 1) / 2);
			mut.setValue("e0", effsize_pos.subset(which_gene - 1, 3)); 
			mut.setValue("e1", effsize_pos.subset(which_gene - 1, 4)); 	
		}
	}
	//pos_mutated = setIntersection(allmuts.position, range_genes);
	//muts = allmuts[which(any(allmuts.position == pos_mutated))];
	//print(muts.position);
	//muts.setMutationType(1);
	//muts = sim.subpopulations.individuals.genome1.mutationsOfType(1);
	//which_gene = asInteger((findInterval(muts.position, trait_locs) + 1) / 2);
	//print(which_gene);
	//
	//
	

	defineGlobal("Host_states", labels);
	//sim.outputFull("initial.output");
}

// Contact network read-in module
1 early() {
	// Read into the contact network file
	lines_contact = readFile(paste0(cwdir, "/contact_network.adjlist.modified"));
	//lines_contact = lines_contact[substr(lines_contact, 0) != "#"];
	for (l in lines_contact)
	{
		ll = strsplit(l, " ");
		ll = asInteger(strsplit(l, " "));
		host = ll[0];
		contact_size = length(ll) - 1;
		//if (length(ll) > 1)
		//{
		//	end_index = length(ll) - 1;
		//	for (cont in ll[1:end_index])
		//	{
		//		if (cont=="")  // Make sure input is correct and get rid of this
		//		{
		//			contacts = c(contacts);
		//		}
		//		else
		//		{
		//			contacts = c(contacts, asInteger(cont));
		//		}
		//	}
		//}
		if (contact_size > 0)
		{
			sim.subpopulations[host].setValue("Contacts", ll[1:contact_size]);
		}
		else
		{
			sim.subpopulations[host].setValue("Contacts", c());
		}
	}
}


// Every existing TB produces a replicate of themselves, to account for the mutation issues
s0 reproduction() {
	itself = individual.subpopulation.addRecombinant(individual.genome1, NULL, NULL, NULL, NULL, NULL);
	itself.tag = individual.tag;
	}


// all kinds of reproduction module
s1 reproduction()
{
	// Transmission
	infectors = which(Host_states==2);
	
	for (infector in infectors)
	{	
		infector_subpop = sim.subpopulations[infector];
		contact_ids = infector_subpop.getValue("Contacts");
		if (length(contact_ids)>0)
		{
			infector_pathogen = sample(infector_subpop.individuals, 1);
			//muts_info = rep(0, length(range_genes));
			//contains_or_not = match(infector_pathogen.genome1.mutations.position, range_genes);
			//muts_info[contains_or_not[which(contains_or_not >= 0)]] = 1;
			//transmissibility = sum(traits_transmissibility * muts_info);
			muts = infector_pathogen.genome1.mutationsOfType(1);
			transmissibility = size(muts) ? sum(muts.getValue("e0")) else 0.0;


			trans_event = rbinom(length(contact_ids), 1, Infection_rate * transmissibility);
			contacts_states = Host_states[contact_ids];
			
			if (super_infection==T) { infectee_id = contact_ids[which((trans_event==1)&(sim.subpopulations[contact_ids].individualCount < cap_withinhost))]; }
			else { infectee_id = contact_ids[which((trans_event==1)&(contacts_states==0))]; }
			for (i in infectee_id)
			{
				child = sim.subpopulations[i].addRecombinant(infector_pathogen.genome1, NULL, NULL, NULL, NULL, NULL);
				child.tag = infector;
				line = paste(community.tick, infector, i);
				writeFile(paste0(cwdir, "/infection_raw.txt"), line, append=T);
			}
		}
	}
	
	// Within-host reproduction if within-host reproduction is true.
	if (within_host_evolution==T)
	{
		host_ids = which((Host_states==2)&(sim.subpopulations.individualCount < cap_withinhost));
	
		for (i in host_ids)
		{
			reproduce_event = which(rbinom(sim.subpopulations[i].individualCount, 1, within_host_reproduct_rate)==1);
			if (length(reproduce_event)>0)
			{
				for (j in reproduce_event)
				{
					child = sim.subpopulations[i].addRecombinant(sim.subpopulations[i].individuals[j].genome1, NULL, NULL, NULL, NULL, NULL);
					child.tag = host_size;
				}
			}
		}
	}
	self.active=F;
}


// SEIR state transition with drug treatment and resistance
s6 early()
{
	inds = sim.subpopulations.individuals;
	sim.killIndividuals(inds[inds.age > 0]);
	
	//defineGlobal("sampled_hosts", c());
	hosts = sim.subpopulations;
	recovered_genomes = c();
	recovered_hosts = c();
	popsizeminus1 = host_size-1;
	
	// Deal with exposed individuals
	e_inds = which(Host_states==1); // deal with 1&2 first
	//sim.subpopulations[e_inds].individuals.tag = host_size;
	draw_uniform = runif(length(e_inds));
	state_transition = findInterval(draw_uniform, c(0, activate_rate, activate_rate + ER_rate));
	Host_states[e_inds[which(state_transition==0)]]=2; // state_transition=0 means going from latent to active state (1>2)
	recover_from_e = e_inds[which(state_transition==1)];
	if (length(recover_from_e)>0)
	{
		Host_states[recover_from_e]=3;
		for (ind in recover_from_e)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/recovery.txt"), line1, append=T);
		}
		sim.killIndividuals(sim.subpopulations[recover_from_e].individuals);
	}
	
	
	// Deal with infected individuals
	i_inds = which(Host_states==2);
	//sim.subpopulations[i_inds].individuals.tag = host_size;
	draw_uniform = runif(length(i_inds));
	state_transition = findInterval(draw_uniform, c(0, treatment_recovery_rate*sample_rate, treatment_recovery_rate, treatment_recovery_rate + IE_rate));
	recover_from_i = i_inds[which(state_transition<=1)];
	sampled_inds = i_inds[which(state_transition==0)];
	
	if (length(sampled_inds)>0)
	{
		sampled_inds_genomes = c();
		for (ind in sampled_inds)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/sample.txt"), line1, append=T);
			sampled_inds_genomes = c(sampled_inds_genomes, sample(sim.subpopulations[ind].individuals, 1));
		}
		sampled_inds_genomes.genomes.outputVCF(filePath=paste0(cwdir, "/sample_vcfs/", community.tick, ".sampled.vcf"));
	}
	
	actually_recovered = c();
	if (length(recover_from_i)>0)
	{
		for (ind in recover_from_i)
		{
			pathogen = sample(sim.subpopulations[ind].individuals, 1);
			muts = pathogen.genome1.mutationsOfType(1);
			traits_recoveryrate = size(muts) ? sum(muts.getValue("e1")) else 0.0;
			recovery_success_rate = 1.5 - traits_recoveryrate; // 1.5 could be changed, the bigger the effect size for drug resistance mutation is, the smaller the recovery success
			if (runif(1) < recovery_success_rate)
			{
				// print(recovery_success_rate);
				line1 = paste(community.tick, ind);
				writeFile(paste0(cwdir, "/recovery.txt"), line1, append=T);
				actually_recovered = c(actually_recovered, ind);
			}
		}
		Host_states[actually_recovered]=3;
		sim.killIndividuals(sim.subpopulations[actually_recovered].individuals);
	}
	
	
	
	// Deal with susceptible individuals
	s_inds = which((Host_states==0)&(sim.subpopulations.individualCount>0));
	if (super_infection==F)
	{
		for (s_ind in s_inds)
		{
			s_ind_pathogens = sim.subpopulations[s_ind].individuals;
			remain_strain_tag = sample(s_ind_pathogens, 1).tag;
			sim.killIndividuals(s_ind_pathogens[which(s_ind_pathogens.tag!=remain_strain_tag)]);
			line = paste(community.tick, remain_strain_tag, s_ind);
			writeFile(paste0(cwdir, "/infection.txt"), line, append=T);
			remain_strain_tag = host_size;
		}
	}
	else
	{
		sim.subpopulations[s_ind].individuals.tag = host_size;
	}

	draw_uniform = runif(length(s_inds));
	state_transition = findInterval(draw_uniform, c(0, latent_prob));
	Host_states[s_inds[which(state_transition==0)]]=1; //state_transition=0 means going to latent state while =1 means going to active state
	Host_states[s_inds[which(state_transition > 0)]]=2;
	
	
	// Deal with recovered individuals
	r_inds = which(Host_states==3);
	draw_uniform = runif(length(r_inds));
	state_transition = findInterval(draw_uniform, c(0, RS_rate));
	Host_states[r_inds[which(state_transition==0)]]=0;
	Host_states[actually_recovered]=3;
	

}

// SEIR state transition without drug treatment and resistance
s3 early()
{
	inds = sim.subpopulations.individuals;
	sim.killIndividuals(inds[inds.age > 0]);
	
	//defineGlobal("sampled_hosts", c());
	hosts = sim.subpopulations;
	recovered_genomes = c();
	recovered_hosts = c();
	popsizeminus1 = host_size-1;
	
	// Deal with exposed individuals
	e_inds = which(Host_states==1); // deal with 1&2 first
	//sim.subpopulations[e_inds].individuals.tag = host_size;
	draw_uniform = runif(length(e_inds));
	state_transition = findInterval(draw_uniform, c(0, activate_rate, activate_rate + ER_rate));
	Host_states[e_inds[which(state_transition==0)]]=2; // state_transition=0 means going from latent to active state (1>2)
	recover_from_e = e_inds[which(state_transition==1)];
	if (length(recover_from_e)>0)
	{
		Host_states[recover_from_e]=3;
		for (ind in recover_from_e)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/recovery.txt"), line1, append=T);
		}
		sim.killIndividuals(sim.subpopulations[recover_from_e].individuals);
	}
	
	
	// Deal with infected individuals
	i_inds = which(Host_states==2);
	//sim.subpopulations[i_inds].individuals.tag = host_size;
	draw_uniform = runif(length(i_inds));
	state_transition = findInterval(draw_uniform, c(0, Recovery_rate*sample_rate, Recovery_rate, Recovery_rate + IE_rate));
	recover_from_i = i_inds[which(state_transition<=1)];
	sampled_inds = i_inds[which(state_transition==0)];
	
	if (length(sampled_inds)>0)
	{
		sampled_inds_genomes = c();
		for (ind in sampled_inds)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/sample.txt"), line1, append=T);
			sampled_inds_genomes = c(sampled_inds_genomes, sample(sim.subpopulations[ind].individuals, 1));
		}
		sampled_inds_genomes.genomes.outputVCF(filePath=paste0(cwdir, "/sample_vcfs/", community.tick, ".sampled.vcf"));
	}
	
	if (length(recover_from_i)>0)
	{
		Host_states[recover_from_i]=3;
		for (ind in recover_from_i)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, "/recovery.txt"), line1, append=T);
		}
		sim.killIndividuals(sim.subpopulations[recover_from_i].individuals);
	}
	
	
	
	// Deal with susceptible individuals
	s_inds = which((Host_states==0)&(sim.subpopulations.individualCount>0));
	if (super_infection==F)
	{
		for (s_ind in s_inds)
		{
			s_ind_pathogens = sim.subpopulations[s_ind].individuals;
			remain_strain_tag = sample(s_ind_pathogens, 1).tag;
			sim.killIndividuals(s_ind_pathogens[which(s_ind_pathogens.tag!=remain_strain_tag)]);
			line = paste(community.tick, remain_strain_tag, s_ind);
			writeFile(paste0(cwdir, "/infection.txt"), line, append=T);
			remain_strain_tag = host_size;
		}
	}

	draw_uniform = runif(length(s_inds));
	state_transition = findInterval(draw_uniform, c(0, latent_prob));
	Host_states[s_inds[which(state_transition==0)]]=1; //state_transition=0 means going to latent state while =1 means going to active state
	Host_states[s_inds[which(state_transition > 0)]]=2;
	
	
	// Deal with recovered individuals
	r_inds = which(Host_states==3);
	draw_uniform = runif(length(r_inds));
	state_transition = findInterval(draw_uniform, c(0, RS_rate));
	Host_states[r_inds[which(state_transition==0)]]=0;
	

}

// Log
s4 late()
{
	writeFile(paste0(cwdir, "/SIR_trajectory.txt"), paste0(sum(Host_states == 0), ", ", sum(Host_states == 1), ", ", sum(Host_states == 2), ", ", sum(Host_states == 3)), append=T);
}

s5 late() 
{
	sim.simulationFinished();
}


