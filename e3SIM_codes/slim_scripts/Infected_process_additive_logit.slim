s7 early(){
	i_inds = which(current_hoststates==2);
	hosts = sim.subpopulations;

	// First deal with recovery
	draw_uniform = runif(length(i_inds));
	state_transition = findInterval(draw_uniform, c(0, I_R_rate[current_epoch]));
	recover_from_i = i_inds[which(state_transition==0)]; // Instant recovery
	treatment_trials = i_inds[which(state_transition>0)];

	if (length(recover_from_i) > 0)
	{
		for (ind in recover_from_i)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, runid, "/recovery.csv"), line1, append=T, compress=T);
		}
		sim.killIndividuals(hosts[recover_from_i].individuals);
		Host_states[recover_from_i] = 3;
	}

	actually_recovered = c();
	if (length(treatment_trials)>0)
	{
		for (ind in treatment_trials)
		{
			pathogens = hosts[ind].individuals;
			for (pathogen in pathogens)
			{
				muts = pathogen.genome1.mutationsOfType(1);
				odds_survival = logit_s[current_epoch] + alpha_drug[drugresistance_effsize[current_epoch] - 1] * additive_trait(muts, paste0("drug_resistance_", drugresistance_effsize[current_epoch]));

				survival_prob = exp(odds_survival) / (1 + exp(odds_survival));

				//the bigger the effect size for drug resistance mutation is, the less probable that the the pathogen dies
				if (runif(1) > survival_prob)
				{
					actually_recovered = c(actually_recovered, pathogen);
				}
			}
		}
		if (length(actually_recovered) > 0)
		{
			sim.killIndividuals(actually_recovered);
		}

		cleared_hosts = treatment_trials[which(hosts[treatment_trials].individualCount==0)];
		if (length(cleared_hosts) > 0)
		{
			for (ind in cleared_hosts)
			{
				line1 = paste(community.tick, ind);
				writeFile(paste0(cwdir, runid, "/recovery.csv"), line1, append=T, compress=T);
			}
			Host_states[cleared_hosts] = 3;
		}
	}


	// Then deal with all the other transitions, has to call current infected individuals

	// Sampling
	i_inds = which(Host_states==2);
	draw_uniform = runif(length(i_inds));
	state_transition = findInterval(draw_uniform, c(0, sample_rate[current_epoch] * recovery_prob_after_sampling[current_epoch], sample_rate[current_epoch], sample_rate[current_epoch] + I_E_rate[current_epoch]));
	recover_from_sampling = i_inds[which(state_transition==0)];
	sampled_inds = i_inds[which(state_transition<=1)];
	go_latent_inds = i_inds[which(state_transition==2)];
	
	if (length(sampled_inds)>0)
	{
		sampled_inds_genomes = c();
		for (ind in sampled_inds)
		{
			sampled_pathogen = sample(hosts[ind].individuals, 1);
			line1 = paste(community.tick, ind, sampled_pathogen.tag);
			writeFile(paste0(cwdir, runid, "/sample.csv"), line1, append=T, compress=T);
			sampled_inds_genomes = c(sampled_inds_genomes, sampled_pathogen);
		}
		sim.treeSeqRememberIndividuals(sampled_inds_genomes);
	}
	
	if (length(recover_from_sampling)>0)
	{
		for (ind in recover_from_sampling)
		{
			line1 = paste(community.tick, ind);
			writeFile(paste0(cwdir, runid, "/recovery.csv"), line1, append=T, compress=T);
		}
		sim.killIndividuals(hosts[recover_from_sampling].individuals);
		Host_states[recover_from_sampling] = 3;
	}

	// Go latent

	if (length(go_latent_inds)>0)
	{
		Host_states[go_latent_inds]=1;
	}
}


